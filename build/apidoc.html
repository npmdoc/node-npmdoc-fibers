<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/laverdet/node-fibers"

    >fibers (v1.0.15)</a>
</h1>
<h4>Cooperative multi-tasking for Javascript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.fibers">module fibers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future">
            function <span class="apidocSignatureSpan">fibers.</span>future
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.yield">
            function <span class="apidocSignatureSpan">fibers.</span>yield
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fibers.</span>fibersCreated</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fibers.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fibers.</span>future.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fibers.future">module fibers.future</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.future">
            function <span class="apidocSignatureSpan">fibers.</span>future
            <span class="apidocSignatureSpan">(detach)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.fromPromise">
            function <span class="apidocSignatureSpan">fibers.future.</span>fromPromise
            <span class="apidocSignatureSpan">(promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.task">
            function <span class="apidocSignatureSpan">fibers.future.</span>task
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.wait">
            function <span class="apidocSignatureSpan">fibers.future.</span>wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.wrap">
            function <span class="apidocSignatureSpan">fibers.future.</span>wrap
            <span class="apidocSignatureSpan">(fnOrObject, multi, suffix, stop)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fibers.future.prototype">module fibers.future.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.detach">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>detach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.get">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.isResolved">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>isResolved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.promise">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.proxy">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>proxy
            <span class="apidocSignatureSpan">(future)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.proxyErrors">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>proxyErrors
            <span class="apidocSignatureSpan">(futures)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.resolve">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>resolve
            <span class="apidocSignatureSpan">(arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.resolveSuccess">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>resolveSuccess
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.resolver">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>resolver
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.return">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>return
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.throw">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>throw
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fibers.future.prototype.wait">
            function <span class="apidocSignatureSpan">fibers.future.prototype.</span>wait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fibers" id="apidoc.module.fibers">module fibers</a></h1>


    <h2>
        <a href="#apidoc.element.fibers.future" id="apidoc.element.fibers.future">
        function <span class="apidocSignatureSpan">fibers.</span>future
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Future() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// You can create functions which automatically run in their own fiber and
// return futures that resolve when the fiber returns (this probably sounds
// confusing.. just play with it to understand).
var calcTimerDelta = function(ms) {
	var start = new Date;
	sleep(ms).wait();
	return new Date - start;
}.<span class="apidocCodeKeywordSpan">future</span>(); // &#x3c;-- important!

// And futures also include node-friendly callbacks if you don&#x27;t want to use
// wait()
calcTimerDelta(2000).resolve(function(err, val) {
	console.log(&#x27;Set timer for 2000ms, waited &#x27;+ val+ &#x27;ms&#x27;);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.yield" id="apidoc.element.fibers.yield">
        function <span class="apidocSignatureSpan">fibers.</span>yield
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yield = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Fiber = require(&#x27;fibers&#x27;);

function sleep(ms) {
	var fiber = Fiber.current;
	setTimeout(function() {
		fiber.run();
	}, ms);
	Fiber.<span class="apidocCodeKeywordSpan">yield</span>();
}

Fiber(function() {
	console.log(&#x27;wait... &#x27; + new Date);
	sleep(1000);
	console.log(&#x27;ok... &#x27; + new Date);
}).run();
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fibers.future" id="apidoc.module.fibers.future">module fibers.future</a></h1>


    <h2>
        <a href="#apidoc.element.fibers.future.future" id="apidoc.element.fibers.future.future">
        function <span class="apidocSignatureSpan">fibers.</span>future
        <span class="apidocSignatureSpan">(detach)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">future = function (detach) {
	var fn = this;
	var ret = function() {
		var future = new FiberFuture(fn, this, arguments);
		if (detach) {
			future.detach();
		}
		return future;
	};
	ret.toString = function() {
		return &#x27;&#x3c;&#x3c;Future &#x27;+ fn+ &#x27;.future()&#x3e;&#x3e;&#x27;;
	};
	return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// You can create functions which automatically run in their own fiber and
// return futures that resolve when the fiber returns (this probably sounds
// confusing.. just play with it to understand).
var calcTimerDelta = function(ms) {
	var start = new Date;
	sleep(ms).wait();
	return new Date - start;
}.<span class="apidocCodeKeywordSpan">future</span>(); // &#x3c;-- important!

// And futures also include node-friendly callbacks if you don&#x27;t want to use
// wait()
calcTimerDelta(2000).resolve(function(err, val) {
	console.log(&#x27;Set timer for 2000ms, waited &#x27;+ val+ &#x27;ms&#x27;);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.fromPromise" id="apidoc.element.fibers.future.fromPromise">
        function <span class="apidocSignatureSpan">fibers.future.</span>fromPromise
        <span class="apidocSignatureSpan">(promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise) {
	var future = new Future;
	promise.then(function(val) {
		future.return(val);
	}, function(err) {
		future.throw(err);
	});
	return future;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.task" id="apidoc.element.fibers.future.task">
        function <span class="apidocSignatureSpan">fibers.future.</span>task
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">task = function (fn) {
	if (arguments.length === 1) {
		return fn.future()();
	} else {
		var future = new Future, pending = arguments.length, error, values = new Array(arguments.length);
		for (var ii = 0; ii &#x3c; arguments.length; ++ii) {
			arguments[ii].future()().resolve(function(ii, err, val) {
				if (err) {
					error = err;
				}
				values[ii] = val;
				if (--pending === 0) {
					if (error) {
						future.throw(error);
					} else {
						future.return(values);
					}
				}
			}.bind(null, ii));
		}
		return future;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	$ cat ls.js

```javascript
var Future = require(&#x27;fibers/future&#x27;);
var fs = Future.wrap(require(&#x27;fs&#x27;));

Future.<span class="apidocCodeKeywordSpan">task</span>(function() {
	// Get a list of files in the directory
	var fileNames = fs.readdirFuture(&#x27;.&#x27;).wait();
	console.log(&#x27;Found &#x27;+ fileNames.length+ &#x27; files&#x27;);

	// Stat each file
	var stats = [];
	for (var ii = 0; ii &#x3c; fileNames.length; ++ii) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.wait" id="apidoc.element.fibers.future.wait">
        function <span class="apidocSignatureSpan">fibers.future.</span>wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wait() {

	// Normalize arguments + pull out a FiberFuture for reuse if possible
	var futures = [], singleFiberFuture;
	for (var ii = 0; ii &#x3c; arguments.length; ++ii) {
		var arg = arguments[ii];
		if (arg instanceof Future) {
			// Ignore already resolved fibers
			if (arg.isResolved()) {
				continue;
			}
			// Look for fiber reuse
			if (!singleFiberFuture &#x26;&#x26; arg instanceof FiberFuture &#x26;&#x26; !arg.started) {
				singleFiberFuture = arg;
				continue;
			}
			futures.push(arg);
		} else if (arg instanceof Array) {
			for (var jj = 0; jj &#x3c; arg.length; ++jj) {
				var aarg = arg[jj];
				if (aarg instanceof Future) {
					// Ignore already resolved fibers
					if (aarg.isResolved()) {
						continue;
					}
					// Look for fiber reuse
					if (!singleFiberFuture &#x26;&#x26; aarg instanceof FiberFuture &#x26;&#x26; !aarg.started) {
						singleFiberFuture = aarg;
						continue;
					}
					futures.push(aarg);
				} else {
					throw new Error(aarg+ &#x27; is not a future&#x27;);
				}
			}
		} else {
			throw new Error(arg+ &#x27; is not a future&#x27;);
		}
	}

	// Resumes current fiber
	var fiber = Fiber.current;
	if (!fiber) {
		throw new Error(&#x27;Can\&#x27;t wait without a fiber&#x27;);
	}

	// Resolve all futures
	var pending = futures.length + (singleFiberFuture ? 1 : 0);
	function cb() {
		if (!--pending) {
			fiber.run();
		}
	}
	for (var ii = 0; ii &#x3c; futures.length; ++ii) {
		futures[ii].resolve(cb);
	}

	// Reusing a fiber?
	if (singleFiberFuture) {
		singleFiberFuture.started = true;
		try {
			singleFiberFuture.return(
				singleFiberFuture.fn.apply(singleFiberFuture.context, singleFiberFuture.args));
		} catch(e) {
			singleFiberFuture.throw(e);
		}
		--pending;
	}

	// Yield this fiber
	if (pending) {
		Fiber.yield();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Future = require(&#x27;fibers/future&#x27;);
var fs = Future.wrap(require(&#x27;fs&#x27;));

Future.task(function() {
	// Get a list of files in the directory
	var fileNames = fs.readdirFuture(&#x27;.&#x27;).<span class="apidocCodeKeywordSpan">wait</span>();
	console.log(&#x27;Found &#x27;+ fileNames.length+ &#x27; files&#x27;);

	// Stat each file
	var stats = [];
	for (var ii = 0; ii &#x3c; fileNames.length; ++ii) {
		stats.push(fs.statFuture(fileNames[ii]));
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.wrap" id="apidoc.element.fibers.future.wrap">
        function <span class="apidocSignatureSpan">fibers.future.</span>wrap
        <span class="apidocSignatureSpan">(fnOrObject, multi, suffix, stop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (fnOrObject, multi, suffix, stop) {
	if (typeof fnOrObject === &#x27;object&#x27;) {
		var wrapped = Object.create(fnOrObject);
		for (var ii in fnOrObject) {
			if (wrapped[ii] instanceof Function) {
				wrapped[suffix === undefined ? ii+ &#x27;Future&#x27; : ii+ suffix] = Future.wrap(wrapped[ii], multi, suffix, stop);
			}
		}
		return wrapped;
	} else if (typeof fnOrObject === &#x27;function&#x27;) {
		var fn = function() {
			var future = new Future;
			var args = Array.prototype.slice.call(arguments);
			if (multi) {
				var cb = future.resolver();
				args.push(function(err) {
					cb(err, Array.prototype.slice.call(arguments, 1));
				});
			} else {
				args.push(future.resolver());
			}
			future._ = fnOrObject.apply(this, args);
			return future;
		}
		// Modules like `request` return a function that has more functions as properties. Handle this
		// in some kind of reasonable way.
		if (!stop) {
			var proto = Object.create(fnOrObject);
			for (var ii in fnOrObject) {
				if (fnOrObject.hasOwnProperty(ii) &#x26;&#x26; fnOrObject[ii] instanceof Function) {
					proto[ii] = proto[ii];
				}
			}
			fn.__proto__ = Future.wrap(proto, multi, suffix, true);
		}
		return fn;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Using `Future` to wrap existing node functions. At no point is the node event
loop blocked:

	$ cat ls.js

```javascript
var Future = require(&#x27;fibers/future&#x27;);
var fs = Future.<span class="apidocCodeKeywordSpan">wrap</span>(require(&#x27;fs&#x27;));

Future.task(function() {
	// Get a list of files in the directory
	var fileNames = fs.readdirFuture(&#x27;.&#x27;).wait();
	console.log(&#x27;Found &#x27;+ fileNames.length+ &#x27; files&#x27;);

	// Stat each file
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fibers.future.prototype" id="apidoc.module.fibers.future.prototype">module fibers.future.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fibers.future.prototype.detach" id="apidoc.element.fibers.future.prototype.detach">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>detach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detach = function () {
		this.resolve(function(err) {
			if (err) {
				throw err;
			}
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		f.wait()
	});

	// Print file size
	for (var ii = 0; ii &#x3c; fileNames.length; ++ii) {
		console.log(fileNames[ii]+ &#x27;: &#x27;+ stats[ii].get().size);
	}
}).<span class="apidocCodeKeywordSpan">detach</span>();
```

	$ node ls.js
	Found 11 files
	bin: 4096
	fibers.js: 1708
	.gitignore: 37
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.get" id="apidoc.element.fibers.future.prototype.get">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
		if (!this.resolved) {
			throw new Error(&#x27;Future must resolve before value is ready&#x27;);
		} else if (this.error) {
			// Link the stack traces up
			var error = this.error;
			var localStack = {};
			Error.captureStackTrace(localStack, Future.prototype.get);
			var futureStack = Object.getOwnPropertyDescriptor(error, &#x27;futureStack&#x27;);
			if (!futureStack) {
				futureStack = Object.getOwnPropertyDescriptor(error, &#x27;stack&#x27;);
				if (futureStack) {
					Object.defineProperty(error, &#x27;futureStack&#x27;, futureStack);
				}
			}
			if (futureStack &#x26;&#x26; futureStack.get) {
				Object.defineProperty(error, &#x27;stack&#x27;, {
					get: function() {
						var stack = futureStack.get.apply(error);
						if (stack) {
							stack = stack.split(&#x27;\n&#x27;);
							return [stack[0]]
								.concat(localStack.stack.split(&#x27;\n&#x27;).slice(1))
								.concat(&#x27;    - - - - -&#x27;)
								.concat(stack.slice(1))
								.join(&#x27;\n&#x27;);
						} else {
							return localStack.stack;
						}
					},
					set: function(stack) {
						Object.defineProperty(error, &#x27;stack&#x27;, {
							value: stack,
							configurable: true,
							enumerable: false,
							writable: true,
						});
					},
					configurable: true,
					enumerable: false,
				});
			}
			throw error;
		} else {
			return this.value;
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}
	stats.map(function(f) {
		f.wait()
	});

	// Print file size
	for (var ii = 0; ii &#x3c; fileNames.length; ++ii) {
		console.log(fileNames[ii]+ &#x27;: &#x27;+ stats[ii].<span class="apidocCodeKeywordSpan">get</span>().size);
	}
}).detach();
```

	$ node ls.js
	Found 11 files
	bin: 4096
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.isResolved" id="apidoc.element.fibers.future.prototype.isResolved">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>isResolved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isResolved = function () {
		return this.resolved === true;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	// Normalize arguments + pull out a FiberFuture for reuse if possible
	var futures = [], singleFiberFuture;
	for (var ii = 0; ii &#x3c; arguments.length; ++ii) {
		var arg = arguments[ii];
		if (arg instanceof Future) {
			// Ignore already resolved fibers
			if (arg.<span class="apidocCodeKeywordSpan">isResolved</span>()) {
				continue;
			}
			// Look for fiber reuse
			if (!singleFiberFuture &#x26;&#x26; arg instanceof FiberFuture &#x26;&#x26; !arg.started) {
				singleFiberFuture = arg;
				continue;
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.promise" id="apidoc.element.fibers.future.prototype.promise">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promise = function () {
		var that = this;
		return new Promise(function(resolve, reject) {
			that.resolve(function(err, val) {
				if (err) {
					reject(err);
				} else {
					resolve(val);
				}
			});
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.proxy" id="apidoc.element.fibers.future.prototype.proxy">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>proxy
        <span class="apidocSignatureSpan">(future)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">proxy = function (future) {
		this.resolve(function(err, val) {
			if (err) {
				future.throw(err);
			} else {
				future.return(val);
			}
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of error, and the second is a function(val){} callback.
*/
Future.prototype.resolve = function(/* errback or future, callback */) { ... }

/**
* Propogate results to another future.
*
* Example usage: future1.<span class="apidocCodeKeywordSpan">proxy</span>(future2) // future2 gets automatically resolved with however
 future1 resolves
*/
Future.prototype.proxy = function(future) { ... }

/**
* Differs from its functional counterpart in that it actually resolves the future. Thus if the
* future threw, future.wait() will throw.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.proxyErrors" id="apidoc.element.fibers.future.prototype.proxyErrors">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>proxyErrors
        <span class="apidocSignatureSpan">(futures)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">proxyErrors = function (futures) {
		this.resolve(function(err) {
			if (!err) {
				return;
			}
			if (futures instanceof Array) {
				for (var ii = 0; ii &#x3c; futures.length; ++ii) {
					futures[ii].throw(err);
				}
			} else {
				futures.throw(err);
			}
		});
		return this;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.resolve" id="apidoc.element.fibers.future.prototype.resolve">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>resolve
        <span class="apidocSignatureSpan">(arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (arg1, arg2) {
		if (this.resolved) {
			if (arg2) {
				if (this.error) {
					arg1.throw(this.error);
				} else {
					arg2(this.value);
				}
			} else {
				arg1(this.error, this.value);
			}
		} else {
			(this.callbacks = this.callbacks || []).push([arg1, arg2]);
		}
		return this;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var start = new Date;
	sleep(ms).wait();
	return new Date - start;
}.future(); // &#x3c;-- important!

// And futures also include node-friendly callbacks if you don&#x27;t want to use
// wait()
calcTimerDelta(2000).<span class="apidocCodeKeywordSpan">resolve</span>(function(err, val) {
	console.log(&#x27;Set timer for 2000ms, waited &#x27;+ val+ &#x27;ms&#x27;);
});
```

	$ node sleep.js
	Set timer for 2000ms, waited 2009ms
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.resolveSuccess" id="apidoc.element.fibers.future.prototype.resolveSuccess">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>resolveSuccess
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveSuccess = function (cb) {
		this.resolve(function(err, val) {
			if (err) {
				return;
			}
			cb(val);
		});
		return this;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.resolver" id="apidoc.element.fibers.future.prototype.resolver">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>resolver
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolver = function () {
		return function(err, val) {
			if (err) {
				this.throw(err);
			} else {
				this.return(val);
			}
		}.bind(this);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Future.prototype.isResolved = function() { ... }

/**
* Returns a node-style function which will mark this future as resolved when called.
*
* Example usage:
*   var errback = aFuture.<span class="apidocCodeKeywordSpan">resolver</span>();
*   asyncFunction(arg1, arg2, etc, errback)
*   var result = aFuture.wait();
*/
Future.prototype.resolver = function() { ... }

/**
* Waits for this future to resolve and then invokes a callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.return" id="apidoc.element.fibers.future.prototype.return">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>return
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">return = function (value) {
		if (this.resolved) {
			throw new Error(&#x27;Future resolved more than once&#x27;);
		}
		this.value = value;
		this.resolved = true;

		var callbacks = this.callbacks;
		if (callbacks) {
			delete this.callbacks;
			for (var ii = 0; ii &#x3c; callbacks.length; ++ii) {
				try {
					var ref = callbacks[ii];
					if (ref[1]) {
						ref[1](value);
					} else {
						ref[0](undefined, value);
					}
				} catch(ex) {
					// console.log(&#x27;Resolve cb threw&#x27;, String(ex.stack || ex.message || ex));
					process.nextTick(function() {
						throw(ex);
					});
				}
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Future = require(&#x27;fibers/future&#x27;), wait = Future.wait;

// This function returns a future which resolves after a timeout. This
// demonstrates manually resolving futures.
function sleep(ms) {
	var future = new Future;
	setTimeout(function() {
		future.<span class="apidocCodeKeywordSpan">return</span>();
	}, ms);
	return future;
}

// You can create functions which automatically run in their own fiber and
// return futures that resolve when the fiber returns (this probably sounds
// confusing.. just play with it to understand).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.throw" id="apidoc.element.fibers.future.prototype.throw">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>throw
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throw = function (error) {
		if (this.resolved) {
			throw new Error(&#x27;Future resolved more than once&#x27;);
		} else if (!error) {
			throw new Error(&#x27;Must throw non-empty error&#x27;);
		}
		this.error = error;
		this.resolved = true;

		var callbacks = this.callbacks;
		if (callbacks) {
			delete this.callbacks;
			for (var ii = 0; ii &#x3c; callbacks.length; ++ii) {
				try {
					var ref = callbacks[ii];
					if (ref[1]) {
						ref[0].throw(error);
					} else {
						ref[0](error);
					}
				} catch(ex) {
					// console.log(&#x27;Resolve cb threw&#x27;, String(ex.stack || ex.message || ex));
					process.nextTick(function() {
						throw(ex);
					});
				}
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Throw from this future as returned. All pending callbacks will be invoked immediately.
* Note that execution will continue normally after running this method,
* so make sure you exit appropriately after running throw()
*
* error - the error to throw when get() or wait() is called.
*
* Example usage: aFuture.<span class="apidocCodeKeywordSpan">throw</span>(new Error(&#x22;Something borked&#x22;))
*/
Future.prototype.throw = function(error) { ... }

/**
* &#x22;detach&#x22; this future. Basically this is useful if you want to run a task in a future, you
* aren&#x27;t interested in its return value, but if it throws you don&#x27;t want the exception to be
* lost. If this fiber throws, an exception will be thrown to the event loop and node will
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fibers.future.prototype.wait" id="apidoc.element.fibers.future.prototype.wait">
        function <span class="apidocSignatureSpan">fibers.future.prototype.</span>wait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wait = function () {
		if (this.isResolved()) {
			return this.get();
		}
		Future.wait(this);
		return this.get();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var Future = require(&#x27;fibers/future&#x27;);
var fs = Future.wrap(require(&#x27;fs&#x27;));

Future.task(function() {
	// Get a list of files in the directory
	var fileNames = fs.readdirFuture(&#x27;.&#x27;).<span class="apidocCodeKeywordSpan">wait</span>();
	console.log(&#x27;Found &#x27;+ fileNames.length+ &#x27; files&#x27;);

	// Stat each file
	var stats = [];
	for (var ii = 0; ii &#x3c; fileNames.length; ++ii) {
		stats.push(fs.statFuture(fileNames[ii]));
	}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
